### 第一阶段：构建测试程序

确保你的目录结构如下：

```Plaintext
/home/developer/MyRPC/test_integration/
├── CMakeLists.txt
├── consumer.cpp
├── provider.cpp
├── test.conf
└── user.proto  <-- (记得把源码目录里的 user.proto 复制过来)
```

**1. 编译**

```Bash
cd ~/MyRPC/test_integration
mkdir build
cd build
cmake ..
make
```

*预期结果*：生成 `provider` 和 `consumer` 两个可执行文件，且没有报错。

------

### 第二阶段：基础功能测试 

这是最基本的验证：**一个服务端，一个客户端，一切正常。**

**1. 启动 ZooKeeper** 确保 ZK 服务已开启（这是注册中心的前提）。

```Bash
# Ubuntu
sudo service zookeeper start
# 或者直接启动脚本
# /usr/share/zookeeper/bin/zkServer.sh start
```

**2. 启动服务端 (Provider)** 打开 **终端 A**：

```Bash
cd ~/MyRPC/test_integration/build
./provider --config=../test.conf --log=../log_file/provider_log.log --log_level=INFO 
```

*预期输出*：

```Bash
[2026-01-07 15:50:18.198] [info] [3999582] [mprpcapplication.cpp:627] ========================================
[2026-01-07 15:50:18.198] [info] [3999582] [mprpcapplication.cpp:630]   Log Level: INFO
[2026-01-07 15:50:18.198] [info] [3999582] [mprpcapplication.cpp:631] ========================================
[2026-01-07 15:50:18.198] [info] [3999582] [mprpcapplication.cpp:651] Registering signal handlers...
[2026-01-07 15:50:18.198] [info] [3999582] [mprpcapplication.cpp:663] Signal handlers registered (SIGINT, SIGTERM, SIGQUIT)
[2026-01-07 15:50:18.198] [info] [3999582] [mprpcapplication.cpp:167] Framework initialized successfully!
[2026-01-07 15:50:18.198] [info] [3999582] [mprpcapplication.cpp:168] =================================================
[2026-01-07 15:50:18.198] [info] [3999582] [rpcprovider.cpp:69] RpcProvider initialized: ip=127.0.0.1, port=8000, threads=4, max_msg_size=10485760
[2026-01-07 15:50:18.198] [info] [3999582] [mprpcapplication.cpp:628] Async spdlog initialized successfully!
[2026-01-07 15:50:18.198] [info] [3999582] [mprpcapplication.cpp:629]   Mode: Async (Non-blocking)
[2026-01-07 15:50:18.198] [info] [3999582] [rpcprovider.cpp:207] Registered method: UserServiceRpc.Login,
[2026-01-07 15:50:18.198] [info] [3999582] [rpcprovider.cpp:207] Registered method: UserServiceRpc.Register,
[2026-01-07 15:50:18.198] [info] [3999582] [rpcprovider.cpp:211] Service registered: UserServiceRpc with 2 methods
[2026-01-07 15:50:18.198] [info] [3999582] [rpcprovider.cpp:256] RpcProvider starting at 127.0.0.1:8000 with 4 threads
[2026-01-07 15:50:18.198] [info] [3999582] [mprpcapplication.cpp:224] Registered shutdown hook #1
[2026-01-07 15:50:18.198] [info] [3999582] [zookeeperutil.cpp:62] [ZkClient] Initialized with config:
[2026-01-07 15:50:18.198] [info] [3999582] [zookeeperutil.cpp:63]   Host: 127.0.0.1:2181
[2026-01-07 15:50:18.198] [info] [3999582] [zookeeperutil.cpp:64]   Session Timeout: 30000 ms
[2026-01-07 15:50:18.198] [info] [3999582] [zookeeperutil.cpp:65]   Root Path: /mprpc
[2026-01-07 15:50:18.198] [info] [3999582] [zookeeperutil.cpp:90] [ZkClient] Connecting to ZooKeeper: 127.0.0.1:2181
[2026-01-07 15:50:18.208] [info] [3999592] [zookeeperutil.cpp:591] [ZkClient] Watcher event: type=-1 , state=3 , path=
[2026-01-07 15:50:18.208] [info] [3999592] [zookeeperutil.cpp:597] [ZkClient] Connected to ZooKeeper server.
[2026-01-07 15:50:18.208] [info] [3999582] [zookeeperutil.cpp:118] [ZkClient] Connected successfully!
[2026-01-07 15:50:18.208] [info] [3999582] [mprpcapplication.cpp:224] Registered shutdown hook #2
[2026-01-07 15:50:18.208] [info] [3999582] [zookeeperutil.cpp:455] [ZkClient] Registering service: /mprpc/UserServiceRpc/127.0.0.1:8000
[2026-01-07 15:50:18.210] [info] [3999582] [zookeeperutil.cpp:265] [ZkClient] Node created: /mprpc/UserServiceRpc/127.0.0.1:8000
[2026-01-07 15:50:18.210] [info] [3999582] [zookeeperutil.cpp:472] [ZkClient] Service registered successfully: /mprpc/UserServiceRpc/127.0.0.1:8000
[2026-01-07 15:50:18.210] [info] [3999582] [rpcprovider.cpp:292] Successfully registered service to ZK: UserServiceRpc -> 127.0.0.1:8000
[2026-01-07 15:50:18.210] [info] [3999582] [rpcprovider.cpp:301] RpcProvider enter event loop...
```

- 日志显示 `RpcProvider starting at 127.0.0.1:8000`
- 日志显示 `Successfully registered service to ZK`
- 程序进入阻塞状态，等待连接。

**3. 验证 ZK 节点 (可选但推荐)** 打开 **终端 B**，确认节点是否注册成功：

```Bash
/usr/share/zookeeper/bin/zkCli.sh -server 127.0.0.1:2181
# 进入交互界面后输入：
ls /mprpc/fixbug.UserServiceRpc
# 应该看到类似 [127.0.0.1:8000] 的子节点
```

```Bash
结果：
developer@VM-4-16-ubuntu:~/MyRPC$ /usr/share/zookeeper/bin/zkCli.sh -server 127.0.0.1:2181
log4j:ERROR setFile(null,true) call failed.
java.io.FileNotFoundException: /var/log/zookeeper/zookeeper.log (Permission denied)
        at java.base/java.io.FileOutputStream.open0(Native Method)
        at java.base/java.io.FileOutputStream.open(FileOutputStream.java:298)
        at java.base/java.io.FileOutputStream.<init>(FileOutputStream.java:237)
        at java.base/java.io.FileOutputStream.<init>(FileOutputStream.java:158)
        at org.apache.log4j.FileAppender.setFile(FileAppender.java:294)
        at org.apache.log4j.RollingFileAppender.setFile(RollingFileAppender.java:207)
        at org.apache.log4j.FileAppender.activateOptions(FileAppender.java:165)
        at org.apache.log4j.config.PropertySetter.activate(PropertySetter.java:307)
        at org.apache.log4j.config.PropertySetter.setProperties(PropertySetter.java:172)
        at org.apache.log4j.config.PropertySetter.setProperties(PropertySetter.java:104)
        at org.apache.log4j.PropertyConfigurator.parseAppender(PropertyConfigurator.java:842)
        at org.apache.log4j.PropertyConfigurator.parseCategory(PropertyConfigurator.java:768)
        at org.apache.log4j.PropertyConfigurator.configureRootCategory(PropertyConfigurator.java:648)
        at org.apache.log4j.PropertyConfigurator.doConfigure(PropertyConfigurator.java:514)
        at org.apache.log4j.PropertyConfigurator.doConfigure(PropertyConfigurator.java:580)
        at org.apache.log4j.helpers.OptionConverter.selectAndConfigure(OptionConverter.java:526)
        at org.apache.log4j.LogManager.<clinit>(LogManager.java:127)
        at org.slf4j.impl.Log4jLoggerFactory.<init>(Log4jLoggerFactory.java:66)
        at org.slf4j.impl.StaticLoggerBinder.<init>(StaticLoggerBinder.java:72)
        at org.slf4j.impl.StaticLoggerBinder.<clinit>(StaticLoggerBinder.java:45)
        at org.slf4j.LoggerFactory.bind(LoggerFactory.java:150)
        at org.slf4j.LoggerFactory.performInitialization(LoggerFactory.java:124)
        at org.slf4j.LoggerFactory.getILoggerFactory(LoggerFactory.java:417)
        at org.slf4j.LoggerFactory.getLogger(LoggerFactory.java:362)
        at org.slf4j.LoggerFactory.getLogger(LoggerFactory.java:388)
        at org.apache.zookeeper.ZooKeeperMain.<clinit>(ZooKeeperMain.java:53)
Connecting to 127.0.0.1:2181
Welcome to ZooKeeper!
JLine support is enabled

WATCHER::

WatchedEvent state:SyncConnected type:None path:null
[zk: 127.0.0.1:2181(CONNECTED) 0] ls /mprpc
[UserServiceRpc]
[zk: 127.0.0.1:2181(CONNECTED) 2] ls /mprpc/UserServiceRpc
[127.0.0.1:8000]
[zk: 127.0.0.1:2181(CONNECTED) 3] 
```

现在进入的是 **ZooKeeper 命令行客户端 (CLI, Command Line Interface)**。

- **类比**：这就好比你进入了 Linux 的 Shell（终端），或者 Windows 的 cmd。

- **区别**：Linux Shell 操作的是磁盘上的文件和文件夹；而这个界面操作的是 **ZooKeeper 内存中的数据节点树 (ZNode Tree)**。

- **提示符含义**：

  ```Bash
  [zk: 127.0.0.1:2181(CONNECTED) 0]
  ```

  这表示：你当前连接到了本机 2181 端口的 ZK 服务，状态是“已连接”，这是你输入的第 0 条命令。

**4. 启动客户端 (Consumer)** 打开 **终端 B**：

```Bash
cd ~/MyRPC/test_integration/build
./consumer --config=../test.conf --log=../log_file/consumer_log.log --log_level=INFO 
```

------

### 第三阶段：集群与负载均衡测试

验证框架是否支持 **“多台服务器”** 以及 **“连接池轮询”**。

**1. 准备第二个配置** 我们模拟第二台服务器，监听 8001 端口。

```Bash
# 在 test_integration 目录下
cp test.conf test_8001.conf
# 修改 test_8001.conf 中的端口为 8001 (IP不变，模拟单机多实例)
sed -i 's/rpcserver_port=8000/rpcserver_port=8001/g' test_8001.conf
```

**2. 启动双服务端**

- **终端 A**：运行 8000 端口

  ```Bash
  ./provider --config=../test.conf --log=../log_file/provider_log.log --log_level=INFO 
  ```

- **终端 C**：运行 8001 端口

  ```Bash
  ./provider --config=../test_8001.conf --log=../log_file/provider_8001_log.log --log_level=INFO 
  ```

**3. 运行客户端**

- **终端 B**：

  ```Bash
  ./consumer --config=../test.conf --log=../log_file/consumer_log.log --log_level=INFO 
  ```

**集群测试通过，查看 终端 A 和 终端 C 的输出：**

- 在 `Testing Concurrency` 阶段，可看到 **两个终端都有日志输出**。
- 这证明 `ConnectionPool` 和 `LoadBalance` 逻辑生效了，请求被分发到了两台服务器上。

------

### 第四阶段：健壮性测试 

#### 场景 1：无服务启动

1. 杀掉所有 `provider` 进程。
2. 运行 `consumer`。 *预期*：客户端不应 Crash，而应提示 `Rpc Failed: No service provider found` 或 `connect error`，最后优雅退出。

#### 场景 2：中途宕机 (服务下线)

1. 启动 `provider` (8000)。
2. 启动 `consumer`。
3. **在 consumer 运行的中途**（你可能需要把 consumer 代码里的 sleep 加长，或者用 GDB 断点卡住），手动 `Ctrl+C` 杀掉 `provider`。
4. 或者，先运行一遍 consumer 建立好长连接，杀掉 provider，再运行一遍 consumer。 *预期*：

- ZooKeeper 上的临时节点应在几秒后自动消失。
- Consumer 的 `CallMethod` 应该返回 Failed，错误信息可能是 `Network error` 或 `Connection reset by peer`。
- **最重要的是：Consumer 进程不能崩溃（Segfault）。**

**健壮性测试通过：**

在 `provider` 进程被kill后， `consumer`不会崩溃，能够正常分析出临时节点消失，给出警报。

------

### 常见问题排查 

1. **Consumer 报错 `No service provider found`**
   - 检查 Provider 是否真的启动了。
   - 检查 `test.conf` 里的 ZK IP/Port 是否正确。
   - 用 `zkCli.sh` 检查 ZK 里有没有节点。
2. **Provider 启动报错 `bind error`**
   - 端口被占用了。运行 `lsof -i :8000` 看看是谁占了，杀掉它。
3. **编译报错 `user.pb.h not found`**
   - 确保 `user.proto` 在 `test_integration` 目录下。
   - 确保 CMake 里的 `include_directories(${CMAKE_CURRENT_BINARY_DIR})` 加了。
4. **程序 Crash (Segfault)**
   - 这通常是 shutdown 顺序问题。检查 `consumer.cpp` 最后是否先调了 `MprpcApplication::Shutdown()` 再调 `spdlog::shutdown()`。
   - 检查 ZKClient 的 Hook 是否生效。

